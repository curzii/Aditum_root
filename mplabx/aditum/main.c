/* Main.c file generated by New Project wizard
 *
 * Created:   Thu Jul 28 2016
 * Processor: PIC18F45K20
 * Compiler:  MPLAB XC8
 */

//Includes
#include <xc.h>
#include <pic18f45k20.h>
#include "mcu_config.h"
#include "lcd.h"
#include "menu.h"
#include "eeprom.h"


//Function prototypes
void mcu_initialise();
unsigned char read_keypad();
void latch_keypad(unsigned char*);
void low_isr(void);
void high_isr(void);
void start_routine();
void load_i2c_registers();
void running_display(void);
        
//Variables
int login_timeout = 1800; //login timout in seconds
volatile unsigned char  i2c_reg_addr     = 0;
volatile unsigned char  i2c_r_reg[32] =    {'-','-','-','-','-','-','-','-', 
                                            '-','-','-','-','-','-','-','-',
                                            '-','-','-','-','-','-','-','-',
                                            '-','-','-','-','-','-','-','-',};  //register to read data from
volatile unsigned char  i2c_w_reg[32] =    {'-','-','-','-','-','-','-','-', 
                                            '-','-','-','-','-','-','-','-',
                                            '-','-','-','-','-','-','-','-',
                                            '-','-','-','-','-','-','-','-',};  //register to write data to
unsigned char           EEP_I2C_ADDR = 0x00;                    //Address in EEPROM of I2C address
__EEPROM_DATA(0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);  //Burnt in I2C address in EEPROM. Modify the first value for preprogrammed addresses.
unsigned char           I2C_ADDR;
unsigned char           Machine_ID;
volatile unsigned char  i2c_byte_count   = 0;
volatile unsigned char  current_user[9] = {0,0,0,0,0,0,0,0,0};
volatile unsigned char  current_pin[9]  = {0,0,0,0,0,0,0,0,0};
volatile unsigned char  logged_user[16];
volatile unsigned char  credentials_accepted = 0;

char hx[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
char c[]  = {'0','1','2','3','4','5','6','7','8','9'};
void main(void)
{     
    /**************************************************************************/
    //Variables in main scope
    unsigned char n = 0, p = 0;
    unsigned char x = '_'; 
    /**************************************************************************/
    //Initialisations    
    mcu_initialise();
    Lcd_Init();
    
    /**************************************************************************/
    //Startup Routine  
    start_routine(); 
    /**************************************************************************/
    //main loop
    while (1)
    {  
        for (int i = 0; i < 32; i++)                        //load i2c read and write registers full of -
        {
            i2c_w_reg[i] = '-';
            i2c_r_reg[i] = '-';
        }   
        while (credentials_accepted == 0 )                   //If no user prompt to log in
        {          
            unsigned char buffer[9];
            for (int i = 0; i < 9; i++)
            {
                current_user[i] = '0';
                current_pin[i] = '0';
                buffer[i] = '0';
            }
            n = 0;
            Lcd_Set_Cursor(1,1);
            Lcd_Write_String("Enter your ID:  ");
            Lcd_Set_Cursor(2,1);
            Lcd_Write_String("[ ]             ");
            Lcd_Set_Cursor(2,1);
            //User ID while
            while (n < 10)                          //Exit while once * is pressed or max size
            {
                if (n == 9)
                    break;                
                Lcd_Set_Cursor(2,2);
                Lcd_Write_Char(c[9-n]);
                x = read_keypad();
                if (x != '_')
                {
                    if (((x - '#') == 0)&&(n > 0))  //If # is pressed do backspace
                    { 
                        buffer[n] = '?';
                        Lcd_Set_Cursor(2, 7 + n);
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                        Lcd_Set_Cursor(2, 8 + n);
                        Lcd_Write_Char(' ');
                        Lcd_Set_Cursor(2, 7 + n);
                        n--;                                                             
                    }
                    else if ((x - '#') != 0)        //Else perform normal input operation                                      
                    {
                        if ((x == '*')|(n == 9))
                        {
                            break;
                        }
                        n++;
                        buffer[n-1] = x;
                        Lcd_Set_Cursor(2, 7 + n);
                        Lcd_Write_Char(x);
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                    }
                }                
            }
            for (int i = 0; i < n; i++)            //load buffer into current user and clear buffer
            {
                current_user[8 - i] = buffer[(n-1) - i]; 
                buffer[(n-1) - i] = '0';
            }
            menu_progress_bar(25);
            //PIN while
            p = 0;
            Lcd_Set_Cursor(1,1);
            Lcd_Write_String("Enter your PIN: ");
            Lcd_Set_Cursor(2,1);
            Lcd_Write_String("[ ]             ");
            Lcd_Set_Cursor(2,1);
            while (p < 10)                          //Exit while once * is pressed or max size
            {
                if (p == 9)
                    break;
                char c[] = {'0','1','2','3','4','5','6','7','8','9'};
                Lcd_Set_Cursor(2,2);
                Lcd_Write_Char(c[9-p]);
                x = read_keypad();
                if (x != '_')
                {
                    if (((x - '#') == 0)&&(p > 0))  //If # is pressed do backspace
                    { 
                        buffer[p] = '?';
                        Lcd_Set_Cursor(2, 7 + p);
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                        Lcd_Set_Cursor(2, 8 + p);
                        Lcd_Write_Char(' ');
                        Lcd_Set_Cursor(2, 7 + p);
                        p--;                                                             
                    }
                    else if ((x - '#') != 0)        //Else perform normal input operation                                      
                    {
                        if ((x == '*')|(p == 9))
                        {
                            break;
                        }
                        p++;
                        buffer[p-1] = x;
                        Lcd_Set_Cursor(2, 7 + p);
                        Lcd_Write_Char('*');
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                    }
                }                
            }
            for (int i = 0; i < p; i++)            //load buffer into pin
                current_pin[8 - i] = buffer[(p-1) - i];            
            menu_progress_bar(25);
    /**************************************************************************/
            //PERFORM CREDENTIALS CHECK HERE
    /**************************************************************************/
            load_i2c_registers();
            unsigned char credential_state = 0;
            for (int i = 0; i < 32; i++)
                    i2c_w_reg[i] = '-';
            while ((i2c_w_reg[0] == '-')||(i2c_w_reg[31] == '-'))   //wait to be serviced
            {
                credential_state = i2c_w_reg[0];
                for (int u = 0; u < 16; u++)
                    logged_user[u] = i2c_w_reg[u+1]; 
            }
            for (int i = 0; i < 32; i++)
                    i2c_r_reg[i] = '-';
            if (credential_state == 0xA1)
            {
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("[Access Granted]");
                menu_progress_bar(100);
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("   [ Welcome ]  ");
                for (int i = 0; i < 30; i++)
                {
                    __delay_ms(10);
                }           
                running_display();
            }
            else if (credential_state == 0xA0)
            {
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("[Access  Denied]");
                Lcd_Set_Cursor(2,1);
                Lcd_Write_String("    [ Retry ]   ");
                for (int i = 0; i < 100; i++)
                {
                    __delay_ms(10);
                }
            }
            else
            {
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("[ System Error ]");
                Lcd_Set_Cursor(2,1);
                Lcd_Write_String("    [ Retry ]   ");
                for (int i = 0; i < 100; i++)
                {
                    __delay_ms(10);
                }
            }
        }      
    }
}

void mcu_initialise()
{
    //Load some important variables
    I2C_ADDR    = Eeprom_Read_Byte(EEP_I2C_ADDR);  //Load EEPROM I2C address into RAM
    Machine_ID  = I2C_ADDR - 0x0F;                 //First address is at 0x10    
    //Clock
    //OSCCON = 0b1111011;
    OSCCON = 0x60;                  // IRCFx = 110
    OSCTUNEbits.PLLEN = 0;          // x4 PLL disabled
    //IO
    TRISA = 0x00;
    TRISB = 0x01;
    TRISC = 0b00011000;             //RC3 and RC$ as inputs for I2c
    TRISD = 0x00;                   //PORTD as output to drive LCD and keypad scanning
    LATC           = 0b00011000;     
    //MSSP in 7 bit I2C Slave mode        
    SSPADD         = I2C_ADDR * 2;  // Set I2C address
    SSPCON1        = 0x36;          // SSPEN: Synchronous Serial Port Enable bit - Enables the serial port and configures the SDA and SCL pins as the serial port pins
                                    // CKP: SCK Release Control bit              - Release clock
                                    // SSPM3:SSPM0: SSP Mode Select bits         - 0110 = I2C Slave mode, 7-bit address    
    SSPSTAT        = 0x00;
    SSPCON2        = 0x01;          // GCEN: General Call address (00h) (Slave mode only) 0 = General call address disabled
                                    // SEN: Start Condition Enable/Stretch Enable bit(1) ()Slave mode) 1 = Clock stretching is enabled 
    PIR1bits.SSPIF = 0;             // Clear MSSP interrupt request flag
    PIE1bits.SSPIE = 1;             // Enable MSSP interrupt enable bit
    INTCONbits.GIE_GIEH  = 1;       // GIE/GIEH: Global Interrupt Enable bit
    INTCONbits.PEIE_GIEL = 1;       // PEIE/GIEL: Peripheral Interrupt Enable bit    
    INTCONbits.RBIE = 0;            // Disable Interrupt on Change Pins (RB4:RB7) (This combined with LVP caused MCU reset on RB5 high))
}

unsigned char   read_keypad()
{   
    TRISB = 0b01111000;
    PORTB = 0b00000001;
    //PORTB = 0b00100000;
    if (Y4) {PORTB = 0x00; return '*';}
    if (Y1) {PORTB = 0x00; return '1';}
    if (Y2) {PORTB = 0x00; return '4';}
    if (Y3) {PORTB = 0x00; return '7';}    
    PORTB = 0b00000010;
    //PORTB = 0b01000000;
    if (Y1) {PORTB = 0x00; return '2';}
    if (Y2) {PORTB = 0x00; return '5';}
    if (Y3) {PORTB = 0x00; return '8';}
    if (Y4) {PORTB = 0x00; return '0';}
    PORTB = 0b00000100;
    //PORTB = 0b10000000;
    if (Y1) {PORTB = 0x00; return '3';} 
    if (Y2) {PORTB = 0x00; return '6';}
    if (Y3) {PORTB = 0x00; return '9';}
    if (Y4) {PORTB = 0x00; return '#';} 
    return '_';
}
void latch_keypad(unsigned char* x)
{
    while (*x == read_keypad())
    {
        __delay_ms(20);
    }
    *x = '_';
}

void load_i2c_registers()
{
    //reg map structure:
    //bit   description
    //0-9   Current User ID
    //10-18 Current User PIN
    //31    Checksum
    //INTCONbits.GIE_GIEH  = 0;       // Disable global interrupts
    //Load Current User
    for (int i = 0; i < 9; i++)
        i2c_r_reg[i] = current_user[i];
    //Load Current PIN
    for (int i = 9; i < 18; i++)
        i2c_r_reg[i] = current_pin[i - 9];    
    
    /*CHECKSUM ALGORITHM*/
    int checksum = 0x00;
    for (int i = 0; i < 31; i++)
    {
        checksum += i2c_r_reg[i];
    }
    checksum /= 32;
    i2c_r_reg[31] = checksum;
    /*END CHECKSUM ALGORITHM*/
    
    //INTCONbits.GIE_GIEH  = 1;       // Enable global interrupts
}

void interrupt ISR(void)
{
    unsigned char    sspBuf;
    //load_i2c_registers();
    if (PIR1bits.SSPIF) {
        
        if (!SSPSTATbits.D_NOT_A) {
            //
            // Slave Address 
            //
            i2c_byte_count = 0;

            if (SSPSTATbits.BF) {
                // Discard slave address 
                sspBuf = SSPBUF;    // Clear BF
            }
            
            if (SSPSTATbits.R_NOT_W) {                
                // Reading - read from register map
                SSPCON1bits.WCOL = 0;
                SSPBUF           = i2c_r_reg[i2c_reg_addr++];
            } 
            
        } else {
            //
            // Data bytes 
            //
            i2c_byte_count++;

            if (SSPSTATbits.BF) {
                sspBuf = SSPBUF;    // Clear BF
            }

            if (SSPSTATbits.R_NOT_W) {

                // Multi-byte read - advance to next address
                SSPCON1bits.WCOL = 0;
                SSPBUF           = i2c_r_reg[i2c_reg_addr++];
                LATDbits.LATD6 = 1;
                
            } else {                

                if (i2c_byte_count == 1) {
                    // First write byte is register address
                    i2c_reg_addr = sspBuf;

                } else {
                    // Write to register address - auto advance
                    //   to allow multiple bytes to be written
                    i2c_w_reg[i2c_reg_addr++] = sspBuf; //r?
                }
            }
        }
        // Limit address to size of register map
        i2c_reg_addr %= sizeof(i2c_r_reg);
        
        // Finally
        PIR1bits.SSPIF  = 0;            // Clear MSSP interrupt flag
        SSPCON1bits.CKP = 1;            // Release clock   
    }    
} 

void start_routine()
{
   
    /**************************************************************************/
    //Start Animation
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);
    Lcd_Write_String("   [ Aditum ]   "); 
    for (int i = 0; i < 20; i++)
        __delay_ms(20);
    Lcd_Set_Cursor(2,1);    
    Lcd_Write_String("Rev ");
    Lcd_Write_String(SOFTWARE_VERSION);
    for (int i = 0; i < 50; i++)
        __delay_ms(20);
    Lcd_Set_Cursor(2,1);
    Lcd_Write_String("Device ID ");
    unsigned char a, h, l, dh, dt, d1;
    if (I2C_ADDR != 0)
        a = I2C_ADDR - 0x0F; //0x10 - 0x77
    else
        a = 0;
    //hex to decimal conversion
    dh = (a / 100);
    dt = (a - dh*100) / 10;
    d1 = (a - (dh*100+dt*10));
    Lcd_Write_Char(c[dh]);
    Lcd_Write_Char(c[dt]); 
    Lcd_Write_Char(c[d1]);
    Lcd_Write_Char('|');
    Lcd_Write_Char(hx[I2C_ADDR/16]);
    Lcd_Write_Char(hx[I2C_ADDR - (I2C_ADDR/16)*16]);
    for (int i = 0; i < 40; i++)
        __delay_ms(20);
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);
    Lcd_Write_String("  [  Aditum  ]  ");    
    menu_progress_bar(700);    
    /**************************************************************************/
    //Set up I2C address    
    unsigned char x, n = 0, v;
    if (I2C_ADDR == 0x00)
    {
        v = 0;  //New device, needs I2C address setup
        Lcd_Set_Cursor(1,1);
        Lcd_Write_String("Load I2C setup..");
        menu_progress_bar(300);
        unsigned char I2C_new_ADDR[] = {'0', '0', '0'}; 
        while (v != 1) //while not a valid i2c address
        {        
            Lcd_Set_Cursor(1,1);
            Lcd_Write_String("New Machine ID: ");
            Lcd_Set_Cursor(2,1);
            Lcd_Write_String("       [001-100]");
            Lcd_Set_Cursor(2,1);
            Lcd_Write_Char('_');
            while (n < 3)
            {
                x = read_keypad();
                if (x != '_')
                {
                    if (((x - '#') == 0)&&(n > 0))  //If # is pressed do backspace
                    { 
                        I2C_new_ADDR[n] = 0;
                        Lcd_Set_Cursor(2, n);
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                        Lcd_Set_Cursor(2, 1 + n);
                        Lcd_Write_Char(' ');
                        Lcd_Set_Cursor(2, n);
                        n--;                                                             
                    }
                    else if ((x - '#') != 0)        //Else perform normal input operation                                      
                    {
                        if ((x == '*')|(n == 3))
                        {
                            break;
                        }
                        I2C_new_ADDR[n] = x;
                        n++;
                        Lcd_Set_Cursor(2, n);
                        Lcd_Write_Char(x);
                        Lcd_Write_Char('_');
                        latch_keypad(&x);
                    }
                }
            }           
            //decimal char array to hex conversion for direct insertion into SSPBUFF for I2C address update
            unsigned char new_I2C_address = 0;
            unsigned char b[3];
            for (int i = 0; i < 3; i++)
                b[i] = I2C_new_ADDR[i] - '0';
            new_I2C_address += (100)*(I2C_new_ADDR[0] - '0');
            new_I2C_address +=  (10)*(I2C_new_ADDR[1] - '0');
            new_I2C_address +=   (1)*(I2C_new_ADDR[2] - '0');
            Machine_ID = new_I2C_address;
            new_I2C_address += 0x0F; //first I2C address is at 0x10       
            //I2C address should be between 1 and 100
            char* error_msg;
            if ( ((b[0]==0)&&((b[1]!=0)|(b[2]!=0))) | ((b[0]==1)&&(b[1]==0)&&(b[2]==0)) )   //If Address is valid
            {        
                //hex to decimal conversion for display purposes only
                dh = (new_I2C_address / 100);
                dt = (new_I2C_address - dh*100) / 10;
                d1 = (new_I2C_address - (dh*100+dt*10)); 
                //hex to char conversion for display purposes only
                h = new_I2C_address/16;
                l = new_I2C_address - (new_I2C_address/16)*16;	   
                Lcd_Clear();
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("New Machine ID: ");
                Lcd_Set_Cursor(2,1);
                for (int i = 0; i < 3; i++) 
                  Lcd_Write_Char(I2C_new_ADDR[i]);
                Lcd_Set_Cursor(2, 7);
                Lcd_Write_String("[OK]");
                Lcd_Set_Cursor(2,14);
                Lcd_Write_String("x");
                Lcd_Write_Char(hx[h]);
                Lcd_Write_Char(hx[l]); 
                for (int i = 0; i < 50; i++)
                   __delay_ms(20);
                I2C_ADDR = new_I2C_address;
                Eeprom_Write_Byte(EEP_I2C_ADDR, I2C_ADDR);
                Lcd_Clear();
                Lcd_Set_Cursor(1,1);
                Lcd_Write_String("I2C_ADDR>>EEPROM");
                /*Lcd_Set_Cursor(1,13);
                h = I2C_ADDR/16;
                l = I2C_ADDR - (I2C_ADDR/16)*16;
                Lcd_Write_String("0x");
                Lcd_Write_Char(hx[h]);
                Lcd_Write_Char(hx[l]);*/
                for (int i = 0; i < 10; i++)
                   __delay_ms(20);
                menu_progress_bar(500);                       
                RESET();               
            }    
            else
            {
                if (new_I2C_address == 0)
                    error_msg = "May not be zero!";
                else
                    error_msg = "Out of bounds!  ";
                Lcd_Set_Cursor(2,1);
                Lcd_Write_String(error_msg);
                for (int i = 0; i < 50; i++)
                        __delay_ms(20);
                for (int i = 0; i < 3; i++)
                   I2C_new_ADDR[i] = '0';
                v = 0;
                n = 0;
            }            
        }
    }
    else
    {
        v = 1;  //Continue to interface
    } 
    /**************************************************************************/
    //Wait for I2C Connection
        
}

void running_display(void)
{
    unsigned char exit_running = 0x00;
    Lcd_Clear();
    Lcd_Set_Cursor(1,1);
    unsigned char is_leading_zero = 1, n_c = 0;
    for (int i = 0; i < 9; i++)
    {
        if ((current_user[i] == '0')&&(is_leading_zero))
            continue;
        else 
        {
            is_leading_zero = 0;
            n_c++;
            Lcd_Write_Char(current_user[i]);
        }
    }
    for (int i = 0; i < 13 - n_c; i++)
        Lcd_Write_Char(' ');   
    Lcd_Set_Cursor(2,1);
    for (int i = 0; i < 16; i++)
        Lcd_Write_Char(logged_user[i]);
    
    Lcd_Set_Cursor(1,12);
    Lcd_Write_String("00:00");
    int s = login_timeout, ms = 0;
    char t[] = {'0', '0', ':', '0', '0'};
    while (read_keypad() != '#')
    {
        if (s == 0)
            break;
        __delay_us(265);    //manually calibrated for time accuracy
        ms += 1;
        if (ms == 1000)
        {
            s -= 1;
            ms = 0;
            //Convert seconds to time format mm:ss
            char n[] = {'0','1','2','3','4','5','6','7','8','9'};     
            int hour=s/3600;
            int second=s % 3600;
            int minute=second/60;
            second %= 60;
            Lcd_Set_Cursor(1,12);
            Lcd_Write_Char(n[minute/10]);
            Lcd_Write_Char(n[minute%10]);
            Lcd_Write_Char(':');
            Lcd_Write_Char(n[second/10]);
            Lcd_Write_Char(n[second%10]);
        }       
    }
    Lcd_Clear();
    Lcd_Set_Cursor(1,1);
    Lcd_Write_String("Logging you out.");
    menu_progress_bar(200);
    return;
}
